# 11.匿名函数、作用域和闭包
函数定义三面：
- 函数声明：正规、说明性
- 函数表达式：更宽松、表达力更强
- 匿名函数：匿名性


匿名，指的是函数没有名称。  

【有些情况下，】  
通过使用匿名函数，可让代码更简洁精练，可读性更强，效率更高，甚至更易于维护。  

### 创建和使用  

```js
function handler() { alert("Yeah, that page loaded!"); }
window.onload = handler;
```
简化为
```js
window.onload = function () { alert("Yeah, that page loaded!"); }; // 记得用分号
```
没有使用不必要的名称，  
避免了在其他代码中错误地使用它（网页只加载一次， 该函数只需调用一次，hanlder 只使用一次，且名称常见）

要获取函数的引用，  
一是使用指向函数的变量
一是使用函数表达式  

如果需要从函数返回一个函数，也可返回一个函数表达式

### 问答

- 既然作为一等公民的函数用途这么大，为何其他语言不支持它？
实际上支持（那些当前不支持的也正在考虑这样做）。例如，Scheme 和 Scala 等语言与 JS 一样，全面支持将函数作为一等公民; PHP、最新的 Java 版本、C# 和 Objective-C 等语言在一定程度上支持将函数作为一等公民。每种语言支持的方式都稍有不同。  

### 提升 hoisting
使用`函数声明`创建的函数是在使用`函数表达式`创建的函数之前`定义`的。

函数声明创建的函数，在第一遍处理代码时被定义，函数表达式创建的函数等到第二遍从上到下执行代码时才被定义。  
这意味着可将函数声明放在任何地方（代码的开头、末尾、中间），且可在任何地方调用它们。在代码的任何地方，函数声明创建的函数都是已定义的，就被称为`提升`。  

函数表达式，因为它创建的函数要等到它执行后才被定义，即便函数表达式赋给全局变量。  

作用域是`全局`。这意味着函数被定义后，在代码的`任何地方`都是`可见`的。  

### 嵌套对作用域的影响

在代码顶层定义的函数是全局的，而在函数中之义的函数是局部的。  
【未定义即为 undefined】  
在`函数内部`的什么地方可`引用嵌套函数`的规则，与整个代码的什么地方可引用全局函数的规则相同。  
也就是说，在函数内部，使用函数声明创建了一个嵌套函数，那么，在这个函数的函数体的任何地方，嵌套函数都是已定义的;使用`函数表达式`创建了一个嵌套函数，则在这个函数的函数体内，`仅当函数表达式执行后`，嵌套函数才是`已定义`的。

### 词法作用域 lexical scope

```js
var justAVar = "Oh,don't you worry about it, I'am GLOBAL";

function whereAreYou() {
  var justAVar = "Just an every day LOCAL";

  return justAVar;  // 使用的词法作用域，因此在最近的函数作用域内查找 justAVar
}

var result = whereAreYou();
console.log(result); // => Just an every day LOCAL

```

